<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Tiny Voxel World — Minecrafty (Improved)</title>
<style>
  html,body{height:100%;margin:0;background:#0b1020;color:#ddd;font-family:Inter,system-ui,Arial}
  #wrap{height:100vh;display:flex;align-items:stretch}
  #canvasWrap{flex:1;position:relative}
  canvas{display:block;width:100%;height:100%}
  #ui{position:absolute;left:12px;top:12px;z-index:5;background:rgba(0,0,0,0.28);padding:8px;border-radius:6px}
  #cross{position:absolute;left:50%;top:50%;width:18px;height:18px;margin:-9px 0 0 -9px;pointer-events:none;z-index:4}
  #cross:after{content:'';position:absolute;left:50%;top:50%;width:2px;height:2px;margin:-1px 0 0 -1px;background:white;border-radius:50%}
  button{margin-left:6px}
  #help{position:absolute;right:12px;top:12px;padding:8px;background:rgba(0,0,0,0.25);border-radius:6px}
  #objective {margin-top:6px;color:#ffd981;font-weight:600}
  #hint {font-size:12px;opacity:0.95;margin-top:6px}
  #hotbar {position:absolute;left:50%;bottom:14px;transform:translateX(-50%);display:flex;gap:6px;z-index:6}
  .slot{width:54px;height:54px;background:rgba(0,0,0,0.32);border-radius:6px;display:flex;align-items:center;justify-content:center;flex-direction:column;color:#fff;font-weight:600}
  .slot.sel{outline:3px solid rgba(255,200,80,0.85);box-shadow:0 6px 18px rgba(255,200,80,0.06)}
  .slot span{font-size:12px;opacity:0.9}
  #miniInv{position:absolute;left:12px;bottom:12px;z-index:6;background:rgba(0,0,0,0.28);padding:6px;border-radius:6px;font-size:13px}
  #placedBadge {display:inline-block;margin-left:10px;color:#b6f59a;font-weight:600}
</style>
</head>
<body>
<div id="wrap">
  <div id="canvasWrap">
    <canvas id="c"></canvas>
    <div id="ui">
      WASD move • Space jump • Click to lock mouse • Hold left-click to mine • Right click = place selected
      <button id="regen">Regenerate</button>
      <div id="objective">Objective: Place 25 blocks to activate the beacon</div>
      <div id="hint">Placed: <span id="placedCount">0</span> • Blocks: <span id="count">0</span> • Time: <span id="time">12:00</span></div>
    </div>
    <div id="miniInv"></div>
    <div id="hotbar"></div>
    <div id="help"></div>
    <div id="cross"></div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>

<script>
/* ================================================================
   CONFIG + WORLD SIZE
   ================================================================ */
const SX = 64, SY = 18, SZ = 64; // grid dims (bigger)
const BLOCK_SIZE = 1;
const FALL_DEATH_Y = -12;
const RESPAWN_POS = new THREE.Vector3(0, 5, 0);

/* BLOCK TYPES */
const BT = {
  NONE: 0,
  GRASS: 1,
  DIRT: 2,
  STONE: 3,
  WOOD: 4,
  LEAVES: 5,
  TORCH: 6
};
const BLOCK_NAMES = ['Empty','Grass','Dirt','Stone','Wood','Leaves','Torch'];

/* ================================================================
   THREE SETUP
   ================================================================ */
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x86c7ff);
scene.fog = new THREE.FogExp2(0x86c7ff, 0.0025);
const camera = new THREE.PerspectiveCamera(70, 2, 0.1, 500);
camera.position.set(0, 6, 12);

const sunLight = new THREE.DirectionalLight(0xffffff, 1.0); sunLight.position.set(5,10,7); scene.add(sunLight);
const ambientLight = new THREE.AmbientLight(0x888888, 0.6); scene.add(ambientLight);

/* ================================================================
   DAY/NIGHT + MOON + STARS
   ================================================================ */
const daySky = new THREE.Color(0x86c7ff), sunsetSky = new THREE.Color(0xffb86b), nightSky = new THREE.Color(0x081028);
const DAY_DURATION = 60; let timeOfDay = 12.0;

const moonGeom = new THREE.SphereGeometry(2.0,16,12);
const moonMat = new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0xeef6ff, emissiveIntensity:0.9, roughness:0.9 });
const moonMesh = new THREE.Mesh(moonGeom, moonMat); scene.add(moonMesh);
const moonLight = new THREE.DirectionalLight(0xddeeff, 0.0); scene.add(moonLight); moonLight.target.position.set(0,0,0); scene.add(moonLight.target);

const STAR_COUNT = 800;
const starPositions = new Float32Array(STAR_COUNT*3);
for (let i=0;i<STAR_COUNT;i++){
  const r = 120 + Math.random()*80;
  const theta = Math.acos(THREE.MathUtils.randFloatSpread(1) * 0.6 + 0.4);
  const phi = Math.random()*Math.PI*2;
  starPositions[i*3+0] = r*Math.sin(theta)*Math.cos(phi);
  starPositions[i*3+1] = r*Math.cos(theta);
  starPositions[i*3+2] = r*Math.sin(theta)*Math.sin(phi);
}
const starsGeo = new THREE.BufferGeometry(); starsGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
const starsMat = new THREE.PointsMaterial({ size:1.2, transparent:true, opacity:0.0, depthWrite:false });
const starField = new THREE.Points(starsGeo, starsMat); scene.add(starField);

/* ================================================================
   TEXTURES (procedural canvas textures)
   ================================================================ */
function makeCanvasTexture(drawFn, size=128) {
  const cnv = document.createElement('canvas'); cnv.width = cnv.height = size;
  const ctx = cnv.getContext('2d');
  drawFn(ctx, size);
  const tex = new THREE.CanvasTexture(cnv);
  tex.magFilter = THREE.NearestFilter;
  tex.minFilter = THREE.LinearMipMapLinearFilter;
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  return tex;
}

const grassTex = makeCanvasTexture((ctx,s)=>{
  ctx.fillStyle = '#5aa63b'; ctx.fillRect(0,0,s,s);
  for(let i=0;i<160;i++){
    ctx.fillStyle = `rgba(30,80,30,${0.06+Math.random()*0.14})`;
    ctx.fillRect(Math.random()*s, Math.random()*s, 1+Math.random()*2, 1+Math.random()*2);
  }
});
const dirtTex = makeCanvasTexture((ctx,s)=>{
  ctx.fillStyle = '#8b5a3c'; ctx.fillRect(0,0,s,s);
  for(let i=0;i<90;i++){
    ctx.fillStyle = `rgba(120,80,60,${0.05+Math.random()*0.18})`;
    ctx.fillRect(Math.random()*s, Math.random()*s, 1+Math.random()*3, 1+Math.random()*3);
  }
});
const stoneTex = makeCanvasTexture((ctx,s)=>{
  ctx.fillStyle = '#7e7e7e'; ctx.fillRect(0,0,s,s);
  for(let i=0;i<120;i++){ ctx.fillStyle = `rgba(100,100,100,${0.06+Math.random()*0.25})`; ctx.fillRect(Math.random()*s, Math.random()*s, 1+Math.random()*2, 1+Math.random()*2); }
});
const woodTex = makeCanvasTexture((ctx,s)=>{
  ctx.fillStyle = '#8b6c45'; ctx.fillRect(0,0,s,s);
  ctx.fillStyle = '#7a5d3b';
  for(let i=0;i<12;i++){ ctx.fillRect(0,i*(s/12),s,Math.random()*6+2); }
});
const leafTex = makeCanvasTexture((ctx,s)=>{
  ctx.fillStyle = '#2f8b2f'; ctx.fillRect(0,0,s,s);
  for(let i=0;i<200;i++){
    ctx.fillStyle = `rgba(20,120,20,${0.05+Math.random()*0.2})`;
    ctx.fillRect(Math.random()*s, Math.random()*s, 1, 1);
  }
});

/* ================================================================
   GRID STORAGE
   ================================================================ */
const sizeGrid = SX * SY * SZ;
let blocks = new Uint8Array(sizeGrid); // values = BT.*
let playerPlaced = new Uint8Array(sizeGrid); // 0/1 for whether player placed this block
function idx(x,y,z){ return (y*SZ + z)*SX + x; }
function inside(x,y,z){ return x>=0 && x<SX && y>=0 && y<SY && z>=0 && z<SZ; }

/* ================================================================
   INSTANCED BLOCKS PER TYPE
   ================================================================ */
const dummyGeo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
const instancedMeshes = {}; // type -> { mesh, counters, maps }

function makeInstancedForType(type, material, maxCount = SX*SY*SZ){
  const m = new THREE.InstancedMesh(dummyGeo, material, maxCount);
  m.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
  m.userData.type = type;
  m.userData.count = 0;
  m.userData.indexToInstance = new Int32Array(sizeGrid).fill(-1);
  m.userData.instanceToIndex = new Int32Array(maxCount).fill(-1);
  scene.add(m);
  return m;
}

instancedMeshes[BT.GRASS] = makeInstancedForType(BT.GRASS, new THREE.MeshStandardMaterial({ map: grassTex }));
instancedMeshes[BT.DIRT] = makeInstancedForType(BT.DIRT, new THREE.MeshStandardMaterial({ map: dirtTex }));
instancedMeshes[BT.STONE] = makeInstancedForType(BT.STONE, new THREE.MeshStandardMaterial({ map: stoneTex }));
instancedMeshes[BT.WOOD] = makeInstancedForType(BT.WOOD, new THREE.MeshStandardMaterial({ map: woodTex }));
instancedMeshes[BT.LEAVES] = makeInstancedForType(BT.LEAVES, new THREE.MeshStandardMaterial({ map: leafTex, transparent:true, opacity:0.96 }));
// torches are not boxes visually but we use small cube instanced + separate light entity list
instancedMeshes[BT.TORCH] = makeInstancedForType(BT.TORCH, new THREE.MeshStandardMaterial({ color:0xffcc66, emissive:0xffcc88, emissiveIntensity:0.9 }));

function clearAllInstanceMaps(){
  for (const t in instancedMeshes){
    const m = instancedMeshes[t];
    m.userData.indexToInstance.fill(-1);
    m.userData.instanceToIndex.fill(-1);
    m.count = 0; m.userData.count = 0;
  }
}

const tmpMatrix = new THREE.Matrix4();
function rebuildInstances(){
  clearAllInstanceMaps();
  for (let x=0;x<SX;x++){
    for (let y=0;y<SY;y++){
      for (let z=0;z<SZ;z++){
        const i = idx(x,y,z);
        const b = blocks[i];
        if (!b) continue;
        const worldX = (x - SX/2) * BLOCK_SIZE + BLOCK_SIZE/2;
        const worldY = y * BLOCK_SIZE + BLOCK_SIZE/2;
        const worldZ = (z - SZ/2) * BLOCK_SIZE + BLOCK_SIZE/2;
        tmpMatrix.makeTranslation(worldX, worldY, worldZ);
        const mesh = instancedMeshes[b];
        const inst = mesh.userData.count;
        mesh.setMatrixAt(inst, tmpMatrix);
        mesh.userData.indexToInstance[i] = inst;
        mesh.userData.instanceToIndex[inst] = i;
        mesh.userData.count++;
        mesh.count = mesh.userData.count;
        if (mesh.instanceMatrix) mesh.instanceMatrix.needsUpdate = true;
      }
    }
  }
  document.getElementById('count').textContent = Object.values(instancedMeshes).reduce((s,m)=>s+m.userData.count,0);
}

/* ================================================================
   RAYCAST + HOVER HIGHLIGHT
   ================================================================ */
const raycaster = new THREE.Raycaster();
const clickPoint = new THREE.Vector2(0,0);
let hoverBox = null;
function createHoverBox(){
  const geo = new THREE.BoxGeometry(BLOCK_SIZE*1.02, BLOCK_SIZE*1.02, BLOCK_SIZE*1.02);
  const mat = new THREE.MeshBasicMaterial({ color:0xffff88, wireframe:true, transparent:true, opacity:0.95 });
  hoverBox = new THREE.Mesh(geo, mat);
  hoverBox.visible = false;
  scene.add(hoverBox);
}
createHoverBox();

function pickInstance(){ raycaster.setFromCamera(clickPoint, camera); const hits = raycaster.intersectObjects(Object.values(instancedMeshes).map(o=>o), true); return hits.length ? hits[0] : null; }

function updateHover(){
  const hit = pickInstance();
  if (!hit) { hoverBox.visible = false; return null; }
  const mesh = hit.object;
  const type = mesh.userData.type;
  const instId = hit.instanceId;
  const gidx = mesh.userData.instanceToIndex[instId];
  if (gidx === -1) { hoverBox.visible = false; return null; }
  const gx = gidx % SX; const rest = Math.floor(gidx / SX); const gz = rest % SZ; const gy = Math.floor(rest / SZ);
  const wx = (gx - SX/2) * BLOCK_SIZE + BLOCK_SIZE/2;
  const wy = gy * BLOCK_SIZE + BLOCK_SIZE/2;
  const wz = (gz - SZ/2) * BLOCK_SIZE + BLOCK_SIZE/2;
  hoverBox.position.set(wx, wy, wz);
  hoverBox.visible = true;
  return { hit, mesh, instId, gidx, gx, gy, gz };
}

/* ================================================================
   ADD / REMOVE BLOCKS & INVENTORY + MINING
   ================================================================ */
let placedBlocks = 0;
const MAX_PLACED = 400; // safety cap
const inventory = {};
for (let k in BT) inventory[BT[k]] = 0; // counts per type
inventory[BT.GRASS] = 0; inventory[BT.DIRT]=0; inventory[BT.STONE]=0; inventory[BT.WOOD]=0; inventory[BT.LEAVES]=0; inventory[BT.TORCH]=0;

function updatePlacedBadge(){ document.getElementById('placedCount').textContent = placedBlocks; }

function removeBlockAt(hitInfo){
  if (!hitInfo) return;
  const {mesh, instId, gidx} = hitInfo;
  if (gidx === -1) return;
  const btype = blocks[gidx];
  if (!btype) return;
  // decrement placed count only if it was player-placed
  if (playerPlaced[gidx]) { playerPlaced[gidx]=0; if (placedBlocks>0) placedBlocks--; }
  // add to inventory
  inventory[btype] = (inventory[btype]||0) + 1;
  spawnBreakParticlesFromGridIndex(gidx);
  blocks[gidx] = BT.NONE;
  rebuildInstances();
  playTone(200, 0.06);
}

/* addBlockAdjacent uses currently selected block type */
let selectedBlockType = BT.GRASS;
function addBlockAdjacent(hitInfo){
  if (!hitInfo) return;
  const {hit, mesh, gx, gy, gz} = hitInfo;
  const n = hit.face ? hit.face.normal.clone() : new THREE.Vector3(0,1,0);
  const ax = gx + Math.round(n.x);
  const ay = gy + Math.round(n.y);
  const az = gz + Math.round(n.z);
  if (ax >=0 && ax < SX && ay >=0 && ay < SY && az >=0 && az < SZ && !blocks[idx(ax,ay,az)]) {
    if (placedBlocks >= MAX_PLACED) { flashObjectiveText("Reached max placed blocks!"); return; }
    const gid = idx(ax,ay,az);
    blocks[gid] = selectedBlockType;
    playerPlaced[gid] = 1;
    placedBlocks++;
    rebuildInstances();
    playTone(880, 0.03);
    // if torch, spawn a light
    if (selectedBlockType === BT.TORCH) spawnTorchAt(ax,ay,az);
    checkBridgeGoal();
  }
}

/* ================================================================
   PARTICLES: block break debris
   ================================================================ */
const debris = [];
function spawnBreakParticlesFromGridIndex(gidx){
  if (gidx < 0) return;
  const gx = gidx % SX;
  const rest = Math.floor(gidx / SX);
  const gz = rest % SZ;
  const gy = Math.floor(rest / SZ);
  const worldX = (gx - SX/2)*BLOCK_SIZE + BLOCK_SIZE/2;
  const worldY = gy*BLOCK_SIZE + BLOCK_SIZE/2;
  const worldZ = (gz - SZ/2)*BLOCK_SIZE + BLOCK_SIZE/2;
  const pieces = 10 + Math.floor(Math.random()*8);
  for (let i=0;i<pieces;i++){
    const m = new THREE.Mesh(new THREE.BoxGeometry(0.18,0.18,0.18), new THREE.MeshStandardMaterial({ color:0xffaa66 }));
    m.position.set(worldX + (Math.random()-0.5)*0.6, worldY + (Math.random()-0.5)*0.6, worldZ + (Math.random()-0.5)*0.6);
    m.userData.vel = new THREE.Vector3((Math.random()-0.5)*0.6, 0.6+Math.random()*1.2, (Math.random()-0.5)*0.6);
    m.userData.life = 0.9 + Math.random()*0.5;
    scene.add(m);
    debris.push(m);
  }
}

/* ================================================================
   DECOR: Trees & Rocks (procedural meshes)
   ================================================================ */
const decorGroup = new THREE.Group(); scene.add(decorGroup);
function spawnTreeAt(x,y,z, scale=1.0){
  const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.18*scale,0.22*scale,1*scale,8), new THREE.MeshStandardMaterial({ map: woodTex }));
  trunk.position.set(x, y+0.5*scale, z);
  const leaves = new THREE.Mesh(new THREE.SphereGeometry(0.9*scale,8,8), new THREE.MeshStandardMaterial({ map: leafTex }));
  leaves.position.set(x, y+1.25*scale, z);
  decorGroup.add(trunk); decorGroup.add(leaves);
}
function spawnRockAt(x,y,z, scale=1){
  const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(0.5*scale,0), new THREE.MeshStandardMaterial({ color:0x666666 }));
  rock.position.set(x,y+0.25*scale,z);
  decorGroup.add(rock);
}

/* TORCH LIGHTS */
const torches = []; // { light, gridIndex }
function spawnTorchAt(gx,gy,gz){
  const wx = (gx - SX/2)*BLOCK_SIZE + BLOCK_SIZE/2;
  const wy = gy*BLOCK_SIZE + BLOCK_SIZE/2 + 0.4;
  const wz = (gz - SZ/2)*BLOCK_SIZE + BLOCK_SIZE/2;
  const p = new THREE.PointLight(0xffcc88, 1.2, 6, 2);
  p.position.set(wx, wy, wz);
  scene.add(p);
  torches.push({ light:p, gidx: idx(gx,gy,gz) });
}
function removeTorchAtGridIndex(gidx){
  for (let i=torches.length-1;i>=0;i--){ if (torches[i].gidx === gidx){ scene.remove(torches[i].light); torches.splice(i,1); } }
}

/* ================================================================
   WATER PLANE
   ================================================================ */
const water = new THREE.Mesh(new THREE.PlaneGeometry(SX*1.2, SZ*1.2), new THREE.MeshStandardMaterial({ color:0x2d9df0, transparent:true, opacity:0.35 }));
water.rotation.x = -Math.PI/2; water.position.y = 0.0; scene.add(water);

/* ================================================================
   ISLANDS GENERATION
   ================================================================ */
const islandSpecs = [
  { cx: 0, cz: 0, radius: 3.2, baseH: 1, hVar: 0 },
  { cx: 25, cz: 0, radius: 4.8, baseH: 2, hVar: 2, goal:true },
  { cx: -22, cz: -14, radius: 4.8, baseH: 2, hVar: 2 },
  { cx: 18, cz: -18, radius: 5.2, baseH: 3, hVar: 2 },
  { cx: -8, cz: 20, radius: 4.0, baseH: 2, hVar: 1 },
  { cx: 26, cz: 12, radius: 3.6, baseH: 2, hVar: 2 },
  { cx: -26, cz: 18, radius: 5.6, baseH: 3, hVar: 3 },
  { cx: 6, cz: -30, radius: 4.6, baseH: 2, hVar: 2 },
  { cx: 28, cz: -2, radius: 3.2, baseH: 1, hVar: 1 }
];

let goalIslandCenterWorld = null; let goalReached = false;
function generateIslandsOnly() {
  blocks.fill(BT.NONE);
  playerPlaced.fill(0);
  decorGroup.clear();
  // clear torches
  for (const t of torches) scene.remove(t.light); torches.length = 0;

  const cxGrid = Math.floor(SX/2);
  const czGrid = Math.floor(SZ/2);

  for (let s = 0; s < islandSpecs.length; s++) {
    const sp = islandSpecs[s];
    const centerGX = cxGrid + Math.round(sp.cx);
    const centerGZ = czGrid + Math.round(sp.cz);
    const r = sp.radius;
    for (let dx = -Math.ceil(r); dx <= Math.ceil(r); dx++) {
      for (let dz = -Math.ceil(r); dz <= Math.ceil(r); dz++) {
        const dist = Math.sqrt(dx*dx + dz*dz);
        if (dist > r) continue;
        const localH = Math.max(1, Math.floor(sp.baseH + (1 - (dist / r)) * sp.hVar + (Math.random() * 0.6)));
        for (let dy = 0; dy < localH; dy++) {
          const gx = centerGX + dx;
          const gz = centerGZ + dz;
          const gy = dy;
          if (!inside(gx,gy,gz)) continue;
          // layer: top grass, under = dirt, deeper = stone
          const depth = dy;
          if (depth === localH-1) blocks[idx(gx,gy,gz)] = BT.GRASS;
          else if (depth >= Math.max(0, localH-3)) blocks[idx(gx,gy,gz)] = BT.DIRT;
          else blocks[idx(gx,gy,gz)] = BT.STONE;
        }
      }
    }

    // grass spread
    for (let dx = -Math.floor(r); dx <= Math.floor(r); dx++) {
      for (let dz = -Math.floor(r); dz <= Math.floor(r); dz++) {
        const dist = Math.sqrt(dx*dx + dz*dz);
        if (dist > r*0.85) continue;
        const gx = centerGX + dx;
        const gz = centerGZ + dz;
        for (let gy = SY-1; gy >= 0; gy--) {
          if (!inside(gx,gy,gz)) continue;
          if (blocks[idx(gx,gy,gz)]) { blocks[idx(gx,gy,gz)] = BT.GRASS; break; }
        }
      }
    }

    // deco
    for (let a=0;a<Math.max(1,Math.floor(sp.radius));a++){
      const rx = Math.floor(centerGX + (Math.random()* (r*1.2) - r*0.6));
      const rz = Math.floor(centerGZ + (Math.random()* (r*1.2) - r*0.6));
      for (let gy = SY-1; gy >= 0; gy--) {
        if (!inside(rx,gy,rz)) continue;
        if (blocks[idx(rx,gy,rz)]) {
          const wx = (rx - SX/2)*BLOCK_SIZE + BLOCK_SIZE/2;
          const wy = gy*BLOCK_SIZE + BLOCK_SIZE/2;
          const wz = (rz - SZ/2)*BLOCK_SIZE + BLOCK_SIZE/2;
          if (Math.random() < 0.6) spawnTreeAt(wx, wy, wz, 0.9 + Math.random()*0.6);
          else spawnRockAt(wx, wy, wz, 0.6 + Math.random()*0.8);
          break;
        }
      }
    }

    if (sp.goal) {
      const wx = (centerGX - SX/2)*BLOCK_SIZE + BLOCK_SIZE/2;
      const wz = (centerGZ - SZ/2)*BLOCK_SIZE + BLOCK_SIZE/2;
      goalIslandCenterWorld = new THREE.Vector3(wx, (sp.baseH+1)*BLOCK_SIZE, wz);
    }
  }

  // ensure small start platform
  const start = islandSpecs[0];
  const startGX = Math.floor(SX/2) + Math.round(start.cx);
  const startGZ = Math.floor(SZ/2) + Math.round(start.cz);
  for (let dx=-2; dx<=2; dx++){
    for (let dz=-2; dz<=2; dz++){
      const gx = startGX + dx, gz = startGZ + dz, gy = 1;
      if (inside(gx,gy,gz)) blocks[idx(gx,gy,gz)] = BT.GRASS;
    }
  }
  const startWorldX = (startGX - SX/2) * BLOCK_SIZE + BLOCK_SIZE/2;
  const startWorldZ = (startGZ - SZ/2) * BLOCK_SIZE + BLOCK_SIZE/2;
  RESPAWN_POS.set(startWorldX, 5, startWorldZ);
}

/* ================================================================
   PLAYER, INPUT, and PHYSICS
   ================================================================ */
const player = { pos: RESPAWN_POS.clone(), vel: new THREE.Vector3(), yaw:0, pitch:0, speed:5, radius:0.28, height:1.75, onGround:false };
const keys = {};
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if (e.key === ' ' && player.onGround) player.vel.y = 6; if (e.key >= '1' && e.key <= '6') selectHotbar(parseInt(e.key)); });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

canvas.addEventListener('click', () => { canvas.requestPointerLock(); });
function onMouseMove(e){ if (document.pointerLockElement !== canvas) return; player.yaw -= e.movementX*0.0026; player.pitch -= e.movementY*0.0026; player.pitch = Math.max(-Math.PI/2+0.1, Math.min(Math.PI/2-0.1, player.pitch)); }
document.addEventListener('mousemove', onMouseMove);

let mining = { active:false, startTime:0, target:null, duration:0.7 };
canvas.addEventListener('mousedown', e => {
  if (e.button === 0) {
    const hit = updateHover();
    if (hit) {
      mining.active = true; mining.startTime = performance.now(); mining.target = hit; }
  } else if (e.button === 2) {
    const hit = updateHover(); if (hit) addBlockAdjacent(hit);
  }
});
canvas.addEventListener('mouseup', e => {
  if (e.button === 0) {
    if (mining.active && mining.target){ const held = (performance.now() - mining.startTime)/1000; if (held >= mining.duration) removeBlockAt(mining.target); }
    mining.active = false; mining.target = null;
  }
});
canvas.addEventListener('contextmenu', e => e.preventDefault());

/* ================================================================
   CAMERA: smooth follow + head bob
   ================================================================ */
let walkBob = 0;
function updateCamera(dt){
  const target = new THREE.Vector3(player.pos.x, player.pos.y + player.height*0.85, player.pos.z);
  const moving = !!(keys['w']||keys['a']||keys['s']||keys['d']);
  if (moving) walkBob += dt * 8; else walkBob = 0;
  target.y += Math.sin(walkBob) * 0.06 * (moving ? 1 : 0);
  camera.position.lerp(target, 0.08);
  camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');
}

/* ================================================================
   AUDIO: simple tones for place/remove
   ================================================================ */
let audioCtx = null;
function ensureAudio(){ if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
function playTone(freq=440, duration=0.05){ try { ensureAudio(); const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type = 'sine'; o.frequency.value = freq; g.gain.value = 0.06; o.connect(g); g.connect(audioCtx.destination); o.start(); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration); o.stop(audioCtx.currentTime + duration + 0.02); } catch(e) {} }

/* ================================================================
   BRIDGE GOAL: beacon visual
   ================================================================ */
const GOAL_REQUIRED = 25;
const beacon = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.06,1.8,8), new THREE.MeshStandardMaterial({ color:0xffcc66, emissive:0xffa844, emissiveIntensity:0.7 }));
beacon.visible = false; scene.add(beacon);
function checkBridgeGoal(){
  if (!goalIslandCenterWorld) return;
  if (placedBlocks >= GOAL_REQUIRED && !goalReached) {
    beacon.position.set(goalIslandCenterWorld.x, goalIslandCenterWorld.y + 1.2, goalIslandCenterWorld.z);
    beacon.visible = true; flashObjectiveText("Bridge ready! Now reach the island!"); goalReached = true;
    document.getElementById('objective').textContent = `Objective: Place ${GOAL_REQUIRED} blocks to activate goal. Activated! Reach the beacon.`;
  }
}

let flashTimeout = null;
function flashObjectiveText(msg, ms=1600){ const el = document.getElementById('objective'); const prev = el.textContent; el.textContent = msg; if (flashTimeout) clearTimeout(flashTimeout); flashTimeout = setTimeout(()=>{ el.textContent = prev; flashTimeout = null; }, ms); }

/* ================================================================
   COLLISION AABB helpers
   ================================================================ */
function findCollidingBlock(aabbMin, aabbMax){
  const minGX = Math.floor((aabbMin.x + (SX*BLOCK_SIZE)/2) / BLOCK_SIZE);
  const maxGX = Math.floor((aabbMax.x + (SX*BLOCK_SIZE)/2) / BLOCK_SIZE);
  const minGZ = Math.floor((aabbMin.z + (SZ*BLOCK_SIZE)/2) / BLOCK_SIZE);
  const maxGZ = Math.floor((aabbMax.z + (SZ*BLOCK_SIZE)/2) / BLOCK_SIZE);
  const minGY = Math.floor(aabbMin.y / BLOCK_SIZE);
  const maxGY = Math.floor((aabbMax.y - 1e-6) / BLOCK_SIZE);
  for (let gx = minGX; gx <= maxGX; gx++){
    for (let gz = minGZ; gz <= maxGZ; gz++){
      for (let gy = minGY; gy <= maxGY; gy++){
        if (inside(gx,gy,gz) && blocks[idx(gx,gy,gz)]) {
          const bMin = new THREE.Vector3((gx - SX/2)*BLOCK_SIZE, gy*BLOCK_SIZE, (gz - SZ/2)*BLOCK_SIZE);
          const bMax = new THREE.Vector3(bMin.x + BLOCK_SIZE, bMin.y + BLOCK_SIZE, bMin.z + BLOCK_SIZE);
          if (!(aabbMax.x <= bMin.x || aabbMin.x >= bMax.x || aabbMax.y <= bMin.y || aabbMin.y >= bMax.y || aabbMax.z <= bMin.z || aabbMin.z >= bMax.z)){
            return { gx, gy, gz, bMin, bMax };
          }
        }
      }
    }
  }
  return null;
}

/* ================================================================
   RESIZE / RESPAWN
   ================================================================ */
function resize(){ const w = canvas.clientWidth, h = canvas.clientHeight; if (canvas.width !== w || canvas.height !== h) { renderer.setSize(w,h,false); camera.aspect = w/h; camera.updateProjectionMatrix(); } }
window.addEventListener('resize', resize);
function respawn(){ player.pos.copy(RESPAWN_POS); player.vel.set(0,0,0); player.onGround = false; }

/* ================================================================
   HOTBAR UI + INVENTORY
   ================================================================ */
const hotbarEl = document.getElementById('hotbar');
const miniInvEl = document.getElementById('miniInv');
const HOTBAR_SLOTS = [BT.GRASS, BT.DIRT, BT.STONE, BT.WOOD, BT.TORCH, BT.LEAVES];
let hotbarSel = 0;
function buildHotbar(){ hotbarEl.innerHTML=''; for (let i=0;i<HOTBAR_SLOTS.length;i++){ const s = document.createElement('div'); s.className='slot'+(i===hotbarSel?' sel':''); s.dataset.slot=i; s.innerHTML = `<div style="font-size:11px">${i+1}</div><div style="font-size:13px;margin-top:6px">${BLOCK_NAMES[HOTBAR_SLOTS[i]]}</div><span id="inv${i}"></span>`; s.addEventListener('click', ()=>selectHotbar(i)); hotbarEl.appendChild(s); } updateHotbarCounts(); }
function updateHotbarCounts(){ for (let i=0;i<HOTBAR_SLOTS.length;i++){ const span = document.getElementById('inv'+i); if (span) span.textContent = inventory[HOTBAR_SLOTS[i]]>0?inventory[HOTBAR_SLOTS[i]]:''; const el = hotbarEl.children[i]; el.className = 'slot' + (i===hotbarSel?' sel':''); } miniInvEl.innerHTML = `Selected: <b>${BLOCK_NAMES[selectedBlockType]}</b> (keys 1-6) / Inventory: Grass ${inventory[BT.GRASS]} Dirt ${inventory[BT.DIRT]} Stone ${inventory[BT.STONE]} Wood ${inventory[BT.WOOD]} Torches ${inventory[BT.TORCH]}`; }
function selectHotbar(i){ hotbarSel = i; selectedBlockType = HOTBAR_SLOTS[i]; buildHotbar(); }

/* ================================================================
   ANIMATE LOOP
   ================================================================ */
const clock = new THREE.Clock();
function animate(){
  resize();
  const dt = Math.min(clock.getDelta(), 0.05);

  // day-night
  timeOfDay += (dt * 24.0) / DAY_DURATION; if (timeOfDay >= 24) timeOfDay -= 24;
  const angle = (timeOfDay / 24.0) * Math.PI * 2.0;
  const sunDistance = 50;
  const sx = Math.cos(angle) * sunDistance; const sy = Math.sin(angle) * sunDistance; const sz = Math.sin(angle * 0.5) * (sunDistance * 0.3);
  sunLight.position.set(sx, sy, sz); sunLight.target.position.set(0,0,0); sunLight.target.updateMatrixWorld();
  const sunHeightRaw = sy / sunDistance; const sunHeight = THREE.MathUtils.clamp((sunHeightRaw + 0.0), 0, 1);
  sunLight.intensity = THREE.MathUtils.lerp(0.0, 1.0, sunHeight);
  ambientLight.intensity = THREE.MathUtils.lerp(0.25, 0.85, sunHeight);

  const skyColor = new THREE.Color();
  if (sunHeight > 0.12) { const t = THREE.MathUtils.smoothstep(sunHeight, 0.12, 1.0); skyColor.copy(sunsetSky).lerp(daySky, t); }
  else { const t = THREE.MathUtils.smoothstep(sunHeight, 0.0, 0.12); skyColor.copy(nightSky).lerp(sunsetSky, t); }
  scene.background.copy(skyColor); scene.fog.color.copy(skyColor);

  const moonAngle = angle + Math.PI; const moonDistance=45;
  const mx = Math.cos(moonAngle)*moonDistance; const my = Math.sin(moonAngle)*moonDistance; const mz = Math.sin(moonAngle*0.5)*(moonDistance*0.2);
  moonMesh.position.set(mx,my,mz);
  moonLight.position.set(mx,my,mz); moonLight.target.position.set(0,0,0); moonLight.target.updateMatrixWorld();
  const moonHeightRaw = my / moonDistance; const moonHeight = THREE.MathUtils.clamp((moonHeightRaw + 1)/2, 0, 1);
  moonLight.intensity = THREE.MathUtils.lerp(0.0, 0.7, moonHeight) * (1.0 - sunHeight);
  moonMat.emissiveIntensity = 0.5 + 0.8 * moonHeight;
  const starFade = THREE.MathUtils.clamp((1.0 - sunHeight) * 1.6, 0.0, 1.0);
  starsMat.opacity = starFade; starsMat.needsUpdate = true;

  // UI clock
  const hour = Math.floor(timeOfDay); const minute = Math.floor((timeOfDay - hour) * 60);
  document.getElementById('time').textContent = hour.toString().padStart(2,'0') + ':' + minute.toString().padStart(2,'0');

  // input & movement
  const forward = new THREE.Vector3(); if (keys['w']) forward.z -= 1; if (keys['s']) forward.z += 1; if (keys['a']) forward.x -= 1; if (keys['d']) forward.x += 1;
  if (forward.lengthSq() > 0) forward.normalize();
  const euler = new THREE.Euler(0, player.yaw, 0);
  forward.applyEuler(euler);
  const desiredVelX = forward.x * player.speed;
  const desiredVelZ = forward.z * player.speed;

  player.vel.y -= 9.8 * dt;

  // X
  let newX = player.pos.x + desiredVelX * dt;
  const tmpAABBMin = new THREE.Vector3(), tmpAABBMax = new THREE.Vector3();
  tmpAABBMin.set(newX - player.radius, player.pos.y, player.pos.z - player.radius);
  tmpAABBMax.set(newX + player.radius, player.pos.y + player.height, player.pos.z + player.radius);
  let coll = findCollidingBlock(tmpAABBMin, tmpAABBMax);
  if (!coll) player.pos.x = newX;

  // Z
  let newZ = player.pos.z + desiredVelZ * dt;
  tmpAABBMin.set(player.pos.x - player.radius, player.pos.y, newZ - player.radius);
  tmpAABBMax.set(player.pos.x + player.radius, player.pos.y + player.height, newZ + player.radius);
  coll = findCollidingBlock(tmpAABBMin, tmpAABBMax);
  if (!coll) player.pos.z = newZ;

  // Y
  const newY = player.pos.y + player.vel.y * dt;
  tmpAABBMin.set(player.pos.x - player.radius, newY, player.pos.z - player.radius);
  tmpAABBMax.set(player.pos.x + player.radius, newY + player.height, player.pos.z + player.radius);
  coll = findCollidingBlock(tmpAABBMin, tmpAABBMax);
  if (!coll) { player.pos.y = newY; player.onGround = false; }
  else {
    if (player.vel.y <= 0) {
      const blockTop = coll.bMin.y + BLOCK_SIZE;
      player.pos.y = blockTop; player.vel.y = 0; player.onGround = true;
    } else {
      const blockBottom = coll.bMin.y; player.pos.y = blockBottom - player.height - 1e-4; player.vel.y = 0;
    }
  }

  const gridX = Math.floor((player.pos.x + (SX*BLOCK_SIZE)/2) / BLOCK_SIZE);
  const gridZ = Math.floor((player.pos.z + (SZ*BLOCK_SIZE)/2) / BLOCK_SIZE);
  if (player.pos.y < FALL_DEATH_Y || gridX < -5 || gridX > SX+5 || gridZ < -5 || gridZ > SZ+5) respawn();

  updateCamera(dt);

  // animate debris
  for (let i = debris.length - 1; i >= 0; i--){ const d = debris[i]; d.userData.life -= dt; if (d.userData.life <= 0) { scene.remove(d); debris.splice(i,1); continue; } d.position.addScaledVector(d.userData.vel, dt * 10); d.userData.vel.y -= 9.8 * dt * 0.2; d.material.opacity = Math.max(0.02, d.userData.life / 1.2); if (d.material.transparent === false) d.material.transparent = true; }

  // hover update
  const h = updateHover();

  // mining feedback (show quick highlight progress)
  if (mining.active && mining.target){ const held = (performance.now() - mining.startTime)/1000; const p = Math.min(1, held / mining.duration); hoverBox.material.opacity = 0.9 + p*0.5; if (held >= mining.duration) { removeBlockAt(mining.target); mining.active=false; } }

  // update beacon pulse
  if (beacon.visible) beacon.material.emissiveIntensity = 0.7 + Math.abs(Math.sin(performance.now() * 0.002)) * 0.6;

  // update placed badge & hotbar
  updatePlacedBadge(); updateHotbarCounts();

  // check goal reached
  if (goalReached && beacon.visible){ const d = new THREE.Vector3(player.pos.x - beacon.position.x, player.pos.y - beacon.position.y, player.pos.z - beacon.position.z); if (d.length() < 2.0){ flashObjectiveText("You reached the goal island — mission complete!"); beacon.visible=false; document.getElementById('objective').textContent = "Objective: Completed — congratulations!"; }}

  // render
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

/* ================================================================
   INIT / UI HOOKS
   ================================================================ */
document.getElementById('regen').addEventListener('click', () => { generateIslandsOnly(); rebuildInstances(); respawn(); placedBlocks = 0; updatePlacedBadge(); beacon.visible=false; goalReached=false; document.getElementById('objective').textContent = `Objective: Place ${GOAL_REQUIRED} blocks to activate goal.`; });

// helper: clear children
Object.defineProperty(THREE.Group.prototype, 'clear', { value: function(){ while(this.children.length) { const c = this.children.pop(); try{ this.remove(c); }catch(e){} } } });

/* ================================================================
   STARTUP
   ================================================================ */
// build hotbar UI
buildHotbar();

generateIslandsOnly();
rebuildInstances();
respawn();
updatePlacedBadge();
animate();

</script>
</body>
</html>
